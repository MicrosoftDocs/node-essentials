import { describe, it, beforeEach, expect, vi } from 'vitest';
import { Container } from '../src/data/connect-to-cosmos.js';
import { createTestInputAndResult } from '../src/data/fake-data.js';
import {
  DbDocument,
  DbError,
  isDbError,
  isVerificationErrors,
  RawInput,
} from '../src/data/model.js';
import Verify from '../src/data/verify.js';
import { insertDocument } from '../src/lib/insert.js';

// Mock app dependencies for Cosmos DB setup
vi.mock('../app/data/connect-to-cosmos', () => ({
  connectToContainer: vi.fn(),
  getUniqueId: vi.fn().mockReturnValue('unique-id'),
}));

// Mock app dependencies for input verification
vi.mock('../app/data/verify', () => {
  return {
    default: class {
      static inputVerified = vi.fn();
    },
  };
});

describe('SDK', () => {

  beforeEach(() => {
    // Clear all mocks before each test.
    vi.clearAllMocks();

  });

  it('should return verification error if input is not verified', async () => {
    // Arrange – mock the input verification function to return false.
    vi.mocked(Verify.inputVerified).mockReturnValue(false);

    const fakeContainer = {
      items: {
        create: vi.fn(),
      }
    } as unknown as Container;

    const createFunction = vi.spyOn(fakeContainer.items, 'create');
    createFunction.mockRejectedValue({
        message: 'Verification failed',
    });

    const doc = { name: 'test' };

    // Act – call the function under test.
    const insertDocumentResult = await insertDocument(
      fakeContainer,
      doc as unknown as RawInput,
    );

    // Assert – state verification: result should indicate verification failure.
    if (isVerificationErrors(insertDocumentResult)) {
      expect(insertDocumentResult).toEqual({
        message: 'Verification failed',
      });
    } else {
      throw new Error('Result is not of type VerificationErrors');
    }

    // Assert – behavior verification: ensure create method was not called.
    expect(createFunction).not.toHaveBeenCalled();
  });

  it('should insert document successfully', async () => {
    const { input, result }: { input: RawInput; result: Partial<DbDocument> } = createTestInputAndResult();
    vi.mocked(Verify.inputVerified).mockReturnValue(true);
    
    const myContainer = {
      items: {
        create: vi.fn(),
      },
    } as unknown as Container;
    const mockedContainer = vi.mock(myContainer.items.create);
    mockedContainer.mockResolvedValue({ resource: result });
    
    const insertDocumentResult = await insertDocument(mockedContainer, input);
    expect(insertDocumentResult).toEqual(result);

    expect(mockedContainer).toHaveBeenCalledTimes(1);
    expect(mockedContainer.calls[0][0]).toEqual({
      id: input.id,
      name: result.name,
    });
  });

  it('should return error if db insert fails', async () => {
    // Arrange – create input and expected result data.
    const { input, result } = createTestInputAndResult();

    // Arrange – mock the input verification to return true.
    vi.mocked(Verify.inputVerified).mockReturnValue(true);

    // Arrange – mock the create method to reject with an error.
    const mockError: DbError = {
      message: 'An unknown error occurred',
      code: 500,
    };
    const myContainer = {
      items: {
        create: vi.fn(),
      },
    } as unknown as Container;
    const mockedContainer = vi.mock(myContainer.items.create);
    mockedContainer.mockRejectedValue(mockError);

    // Act – call the function under test.
    const insertDocumentResult = await insertDocument(mockedContainer, input);

    // Assert – verify result is of type DbError.
    if (isDbError(insertDocumentResult)) {
      expect(insertDocumentResult.message).toBe(mockError.message);
    } else {
      throw new Error('Result is not of type DbError');
    }

    // Assert – behavior verification: ensure create was called once with correct arguments.
    expect(mockedContainer).toHaveBeenCalledTimes(1);
    expect(mockedContainer.mock.calls[0][0]).toEqual({
      id: input.id,
      name: result.name,
    });
  });
});